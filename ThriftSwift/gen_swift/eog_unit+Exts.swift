/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: Unit_s, rhs: Unit_s) -> Bool {
  return
    (lhs.attackArea == rhs.attackArea) &&
    (lhs.maxTargetCount == rhs.maxTargetCount) &&
    (lhs.attack == rhs.attack) &&
    (lhs.health == rhs.health) &&
    (lhs.armor == rhs.armor) &&
    (lhs.travelSpeed == rhs.travelSpeed) &&
    (lhs.maxMoveRange == rhs.maxMoveRange) &&
    (lhs.cargo == rhs.cargo) &&
    (lhs.id == rhs.id)
}

extension Unit_s : CustomStringConvertible {

  public var description : String {
    var desc = "Unit_s("
    desc += "attackArea=\(String(describing: self.attackArea)), "
    desc += "maxTargetCount=\(String(describing: self.maxTargetCount)), "
    desc += "attack=\(String(describing: self.attack)), "
    desc += "health=\(String(describing: self.health)), "
    desc += "armor=\(String(describing: self.armor)), "
    desc += "travelSpeed=\(String(describing: self.travelSpeed)), "
    desc += "maxMoveRange=\(String(describing: self.maxMoveRange)), "
    desc += "cargo=\(String(describing: self.cargo)), "
    desc += "id=\(String(describing: self.id))"
    return desc
  }

}

extension Unit_s : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (attackArea.hashValue)
    result = prime &* result &+ (maxTargetCount.hashValue)
    result = prime &* result &+ (attack.hashValue)
    result = prime &* result &+ (health.hashValue)
    result = prime &* result &+ (armor.hashValue)
    result = prime &* result &+ (travelSpeed.hashValue)
    result = prime &* result &+ (maxMoveRange.hashValue)
    result = prime &* result &+ (cargo.hashValue)
    result = prime &* result &+ (id.hashValue)
    return result
  }

}

extension Unit_s : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["attackArea": 1, "maxTargetCount": 2, "attack": 3, "health": 4, "armor": 5, "travelSpeed": 6, "maxMoveRange": 7, "cargo": 8, "id": 9, ]
  }

  public static var structName: String { return "Unit_s" }

  public static func read(from proto: TProtocol) throws -> Unit_s {
    _ = try proto.readStructBegin()
    var attackArea: Int8!
    var maxTargetCount: Int8!
    var attack: Int64!
    var health: Int64!
    var armor: Int64!
    var travelSpeed: Int64!
    var maxMoveRange: Int64!
    var cargo: Int64!
    var id: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i8):            attackArea = try Int8.read(from: proto)
        case (2, .i8):            maxTargetCount = try Int8.read(from: proto)
        case (3, .i64):             attack = try Int64.read(from: proto)
        case (4, .i64):             health = try Int64.read(from: proto)
        case (5, .i64):             armor = try Int64.read(from: proto)
        case (6, .i64):             travelSpeed = try Int64.read(from: proto)
        case (7, .i64):             maxMoveRange = try Int64.read(from: proto)
        case (8, .i64):             cargo = try Int64.read(from: proto)
        case (9, .string):           id = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(attackArea, named: "attackArea")
    try proto.validateValue(maxTargetCount, named: "maxTargetCount")
    try proto.validateValue(attack, named: "attack")
    try proto.validateValue(health, named: "health")
    try proto.validateValue(armor, named: "armor")
    try proto.validateValue(travelSpeed, named: "travelSpeed")
    try proto.validateValue(maxMoveRange, named: "maxMoveRange")
    try proto.validateValue(cargo, named: "cargo")
    try proto.validateValue(id, named: "id")

    return Unit_s(attackArea: attackArea, maxTargetCount: maxTargetCount, attack: attack, health: health, armor: armor, travelSpeed: travelSpeed, maxMoveRange: maxMoveRange, cargo: cargo, id: id)
  }

}



public func ==(lhs: Army_s, rhs: Army_s) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.unitList == rhs.unitList)
}

extension Army_s : CustomStringConvertible {

  public var description : String {
    var desc = "Army_s("
    desc += "id=\(String(describing: self.id)), "
    desc += "unitList=\(String(describing: self.unitList))"
    return desc
  }

}

extension Army_s : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (unitList.hashValue)
    return result
  }

}

extension Army_s : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "unitList": 2, ]
  }

  public static var structName: String { return "Army_s" }

  public static func read(from proto: TProtocol) throws -> Army_s {
    _ = try proto.readStructBegin()
    var id: String!
    var unitList: TList<Unit_s>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case (2, .list):            unitList = try TList<Unit_s>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(unitList, named: "unitList")

    return Army_s(id: id, unitList: unitList)
  }

}



