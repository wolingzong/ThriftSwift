/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: BattleResult_s, rhs: BattleResult_s) -> Bool {
  return
    (lhs.winnerSide == rhs.winnerSide) &&
    (lhs.loserSide == rhs.loserSide)
}

extension BattleResult_s : CustomStringConvertible {

  public var description : String {
    var desc = "BattleResult_s("
    desc += "winnerSide=\(String(describing: self.winnerSide)), "
    desc += "loserSide=\(String(describing: self.loserSide))"
    return desc
  }

}

extension BattleResult_s : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (winnerSide.hashValue)
    result = prime &* result &+ (loserSide.hashValue)
    return result
  }

}

extension BattleResult_s : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["winnerSide": 1, "loserSide": 2, ]
  }

  public static var structName: String { return "BattleResult_s" }

  public static func read(from proto: TProtocol) throws -> BattleResult_s {
    _ = try proto.readStructBegin()
    var winnerSide: Army_s!
    var loserSide: Army_s!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           winnerSide = try Army_s.read(from: proto)
        case (2, .struct):           loserSide = try Army_s.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(winnerSide, named: "winnerSide")
    try proto.validateValue(loserSide, named: "loserSide")

    return BattleResult_s(winnerSide: winnerSide, loserSide: loserSide)
  }

}



fileprivate final class EOG_BattleSimulation_BattleSimulation_args {

  fileprivate var side1: Army_s

  fileprivate var side2: Army_s


  fileprivate init(side1: Army_s, side2: Army_s) {
    self.side1 = side1
    self.side2 = side2
  }

}

fileprivate func ==(lhs: EOG_BattleSimulation_BattleSimulation_args, rhs: EOG_BattleSimulation_BattleSimulation_args) -> Bool {
  return
    (lhs.side1 == rhs.side1) &&
    (lhs.side2 == rhs.side2)
}

extension EOG_BattleSimulation_BattleSimulation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (side1.hashValue)
    result = prime &* result &+ (side2.hashValue)
    return result
  }

}

extension EOG_BattleSimulation_BattleSimulation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["side1": 1, "side2": 2, ]
  }

  fileprivate static var structName: String { return "EOG_BattleSimulation_BattleSimulation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_BattleSimulation_BattleSimulation_args {
    _ = try proto.readStructBegin()
    var side1: Army_s!
    var side2: Army_s!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           side1 = try Army_s.read(from: proto)
        case (2, .struct):           side2 = try Army_s.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(side1, named: "side1")
    try proto.validateValue(side2, named: "side2")

    return EOG_BattleSimulation_BattleSimulation_args(side1: side1, side2: side2)
  }

}



fileprivate final class EOG_BattleSimulation_BattleSimulation_result {

  fileprivate var success: BattleResult_s?

  fileprivate var error: EOG_Error?


  fileprivate init() { }
  fileprivate init(success: BattleResult_s?, error: EOG_Error?) {
    self.success = success
    self.error = error
  }

}

fileprivate func ==(lhs: EOG_BattleSimulation_BattleSimulation_result, rhs: EOG_BattleSimulation_BattleSimulation_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.error == rhs.error)
}

extension EOG_BattleSimulation_BattleSimulation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (error?.hashValue ?? 0)
    return result
  }

}

extension EOG_BattleSimulation_BattleSimulation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "error": 1, ]
  }

  fileprivate static var structName: String { return "EOG_BattleSimulation_BattleSimulation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_BattleSimulation_BattleSimulation_result {
    _ = try proto.readStructBegin()
    var success: BattleResult_s?
    var error: EOG_Error?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try BattleResult_s.read(from: proto)
        case (1, .struct):           error = try EOG_Error.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return EOG_BattleSimulation_BattleSimulation_result(success: success, error: error)
  }

}



extension EOG_BattleSimulationClient : EOG_BattleSimulation {

  private func send_BattleSimulation(side1: Army_s, side2: Army_s) throws {
    try outProtocol.writeMessageBegin(name: "BattleSimulation", type: .call, sequenceID: 0)
    let args = EOG_BattleSimulation_BattleSimulation_args(side1: side1, side2: side2)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_BattleSimulation() throws -> BattleResult_s {
    try inProtocol.readResultMessageBegin() 
    let result = try EOG_BattleSimulation_BattleSimulation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let error = result.error {
      throw error
    }
    throw TApplicationError(error: .missingResult(methodName: "BattleSimulation"))
  }

  public func BattleSimulation(side1: Army_s, side2: Army_s) throws -> BattleResult_s {
    try send_BattleSimulation(side1: side1, side2: side2)
    try outProtocol.transport.flush()
    return try recv_BattleSimulation()
  }

}

extension EOG_BattleSimulationProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["BattleSimulation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try EOG_BattleSimulation_BattleSimulation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = EOG_BattleSimulation_BattleSimulation_result()
      do {
        result.success = try handler.BattleSimulation(side1: args.side1, side2: args.side2)
      }
      catch let error as EOG_Error { result.error = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "BattleSimulation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = EOG_BattleSimulationProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

