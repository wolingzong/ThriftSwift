/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: ServiceId_s, rhs: ServiceId_s) -> Bool {
  return
    (lhs.serviceId == rhs.serviceId) &&
    (lhs.serviceName == rhs.serviceName) &&
    (lhs.serviceIp == rhs.serviceIp) &&
    (lhs.port == rhs.port)
}

extension ServiceId_s : CustomStringConvertible {

  public var description : String {
    var desc = "ServiceId_s("
    desc += "serviceId=\(String(describing: self.serviceId)), "
    desc += "serviceName=\(String(describing: self.serviceName)), "
    desc += "serviceIp=\(String(describing: self.serviceIp)), "
    desc += "port=\(String(describing: self.port))"
    return desc
  }

}

extension ServiceId_s : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (serviceId.hashValue)
    result = prime &* result &+ (serviceName.hashValue)
    result = prime &* result &+ (serviceIp.hashValue)
    result = prime &* result &+ (port.hashValue)
    return result
  }

}

extension ServiceId_s : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["serviceId": 1, "serviceName": 2, "serviceIp": 3, "port": 4, ]
  }

  public static var structName: String { return "ServiceId_s" }

  public static func read(from proto: TProtocol) throws -> ServiceId_s {
    _ = try proto.readStructBegin()
    var serviceId: Int64!
    var serviceName: String!
    var serviceIp: String!
    var port: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             serviceId = try Int64.read(from: proto)
        case (2, .string):           serviceName = try String.read(from: proto)
        case (3, .string):           serviceIp = try String.read(from: proto)
        case (4, .i32):             port = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serviceId, named: "serviceId")
    try proto.validateValue(serviceName, named: "serviceName")
    try proto.validateValue(serviceIp, named: "serviceIp")
    try proto.validateValue(port, named: "port")

    return ServiceId_s(serviceId: serviceId, serviceName: serviceName, serviceIp: serviceIp, port: port)
  }

}



fileprivate final class EOG_Service_GetServiceId_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: EOG_Service_GetServiceId_args, rhs: EOG_Service_GetServiceId_args) -> Bool {
  return true
}

extension EOG_Service_GetServiceId_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension EOG_Service_GetServiceId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "EOG_Service_GetServiceId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_GetServiceId_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return EOG_Service_GetServiceId_args()
  }

}



fileprivate final class EOG_Service_GetServiceId_result {

  fileprivate var success: ServiceId_s?

  fileprivate var error: EOG_Error?


  fileprivate init() { }
  fileprivate init(success: ServiceId_s?, error: EOG_Error?) {
    self.success = success
    self.error = error
  }

}

fileprivate func ==(lhs: EOG_Service_GetServiceId_result, rhs: EOG_Service_GetServiceId_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.error == rhs.error)
}

extension EOG_Service_GetServiceId_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (error?.hashValue ?? 0)
    return result
  }

}

extension EOG_Service_GetServiceId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "error": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_GetServiceId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_GetServiceId_result {
    _ = try proto.readStructBegin()
    var success: ServiceId_s?
    var error: EOG_Error?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ServiceId_s.read(from: proto)
        case (1, .struct):           error = try EOG_Error.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return EOG_Service_GetServiceId_result(success: success, error: error)
  }

}



fileprivate final class EOG_Service_Heartbeat_args {

  fileprivate var serviceId: ServiceId_s


  fileprivate init(serviceId: ServiceId_s) {
    self.serviceId = serviceId
  }

}

fileprivate func ==(lhs: EOG_Service_Heartbeat_args, rhs: EOG_Service_Heartbeat_args) -> Bool {
  return
    (lhs.serviceId == rhs.serviceId)
}

extension EOG_Service_Heartbeat_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (serviceId.hashValue)
    return result
  }

}

extension EOG_Service_Heartbeat_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["serviceId": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_Heartbeat_args" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_Heartbeat_args {
    _ = try proto.readStructBegin()
    var serviceId: ServiceId_s!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           serviceId = try ServiceId_s.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serviceId, named: "serviceId")

    return EOG_Service_Heartbeat_args(serviceId: serviceId)
  }

}



fileprivate final class EOG_Service_Heartbeat_result {

  fileprivate var error: EOG_Error?


  fileprivate init() { }
  fileprivate init(error: EOG_Error?) {
    self.error = error
  }

}

fileprivate func ==(lhs: EOG_Service_Heartbeat_result, rhs: EOG_Service_Heartbeat_result) -> Bool {
  return
    (lhs.error == rhs.error)
}

extension EOG_Service_Heartbeat_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (error?.hashValue ?? 0)
    return result
  }

}

extension EOG_Service_Heartbeat_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["error": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_Heartbeat_result" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_Heartbeat_result {
    _ = try proto.readStructBegin()
    var error: EOG_Error?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           error = try EOG_Error.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return EOG_Service_Heartbeat_result(error: error)
  }

}



fileprivate final class EOG_Service_ClientConnected_args {

  fileprivate var serviceId: ServiceId_s


  fileprivate init(serviceId: ServiceId_s) {
    self.serviceId = serviceId
  }

}

fileprivate func ==(lhs: EOG_Service_ClientConnected_args, rhs: EOG_Service_ClientConnected_args) -> Bool {
  return
    (lhs.serviceId == rhs.serviceId)
}

extension EOG_Service_ClientConnected_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (serviceId.hashValue)
    return result
  }

}

extension EOG_Service_ClientConnected_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["serviceId": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_ClientConnected_args" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_ClientConnected_args {
    _ = try proto.readStructBegin()
    var serviceId: ServiceId_s!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           serviceId = try ServiceId_s.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serviceId, named: "serviceId")

    return EOG_Service_ClientConnected_args(serviceId: serviceId)
  }

}



fileprivate final class EOG_Service_ClientConnected_result {

  fileprivate var error: EOG_Error?


  fileprivate init() { }
  fileprivate init(error: EOG_Error?) {
    self.error = error
  }

}

fileprivate func ==(lhs: EOG_Service_ClientConnected_result, rhs: EOG_Service_ClientConnected_result) -> Bool {
  return
    (lhs.error == rhs.error)
}

extension EOG_Service_ClientConnected_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (error?.hashValue ?? 0)
    return result
  }

}

extension EOG_Service_ClientConnected_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["error": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_ClientConnected_result" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_ClientConnected_result {
    _ = try proto.readStructBegin()
    var error: EOG_Error?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           error = try EOG_Error.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return EOG_Service_ClientConnected_result(error: error)
  }

}



fileprivate final class EOG_Service_ClientAboutToDisconnect_args {

  fileprivate var serviceId: ServiceId_s


  fileprivate init(serviceId: ServiceId_s) {
    self.serviceId = serviceId
  }

}

fileprivate func ==(lhs: EOG_Service_ClientAboutToDisconnect_args, rhs: EOG_Service_ClientAboutToDisconnect_args) -> Bool {
  return
    (lhs.serviceId == rhs.serviceId)
}

extension EOG_Service_ClientAboutToDisconnect_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (serviceId.hashValue)
    return result
  }

}

extension EOG_Service_ClientAboutToDisconnect_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["serviceId": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_ClientAboutToDisconnect_args" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_ClientAboutToDisconnect_args {
    _ = try proto.readStructBegin()
    var serviceId: ServiceId_s!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           serviceId = try ServiceId_s.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serviceId, named: "serviceId")

    return EOG_Service_ClientAboutToDisconnect_args(serviceId: serviceId)
  }

}



fileprivate final class EOG_Service_ClientAboutToDisconnect_result {

  fileprivate var error: EOG_Error?


  fileprivate init() { }
  fileprivate init(error: EOG_Error?) {
    self.error = error
  }

}

fileprivate func ==(lhs: EOG_Service_ClientAboutToDisconnect_result, rhs: EOG_Service_ClientAboutToDisconnect_result) -> Bool {
  return
    (lhs.error == rhs.error)
}

extension EOG_Service_ClientAboutToDisconnect_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (error?.hashValue ?? 0)
    return result
  }

}

extension EOG_Service_ClientAboutToDisconnect_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["error": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_ClientAboutToDisconnect_result" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_ClientAboutToDisconnect_result {
    _ = try proto.readStructBegin()
    var error: EOG_Error?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           error = try EOG_Error.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return EOG_Service_ClientAboutToDisconnect_result(error: error)
  }

}



fileprivate final class EOG_Service_ConfigurationChanged_args {

  fileprivate var configName: String

  fileprivate var configuration: String


  fileprivate init(configName: String, configuration: String) {
    self.configName = configName
    self.configuration = configuration
  }

}

fileprivate func ==(lhs: EOG_Service_ConfigurationChanged_args, rhs: EOG_Service_ConfigurationChanged_args) -> Bool {
  return
    (lhs.configName == rhs.configName) &&
    (lhs.configuration == rhs.configuration)
}

extension EOG_Service_ConfigurationChanged_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (configName.hashValue)
    result = prime &* result &+ (configuration.hashValue)
    return result
  }

}

extension EOG_Service_ConfigurationChanged_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["configName": 1, "configuration": 2, ]
  }

  fileprivate static var structName: String { return "EOG_Service_ConfigurationChanged_args" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_ConfigurationChanged_args {
    _ = try proto.readStructBegin()
    var configName: String!
    var configuration: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           configName = try String.read(from: proto)
        case (2, .string):           configuration = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(configName, named: "configName")
    try proto.validateValue(configuration, named: "configuration")

    return EOG_Service_ConfigurationChanged_args(configName: configName, configuration: configuration)
  }

}



fileprivate final class EOG_Service_ConfigurationChanged_result {

  fileprivate var error: EOG_Error?


  fileprivate init() { }
  fileprivate init(error: EOG_Error?) {
    self.error = error
  }

}

fileprivate func ==(lhs: EOG_Service_ConfigurationChanged_result, rhs: EOG_Service_ConfigurationChanged_result) -> Bool {
  return
    (lhs.error == rhs.error)
}

extension EOG_Service_ConfigurationChanged_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (error?.hashValue ?? 0)
    return result
  }

}

extension EOG_Service_ConfigurationChanged_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["error": 1, ]
  }

  fileprivate static var structName: String { return "EOG_Service_ConfigurationChanged_result" }

  fileprivate static func read(from proto: TProtocol) throws -> EOG_Service_ConfigurationChanged_result {
    _ = try proto.readStructBegin()
    var error: EOG_Error?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           error = try EOG_Error.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return EOG_Service_ConfigurationChanged_result(error: error)
  }

}



extension EOG_ServiceClient : EOG_Service {

  private func send_GetServiceId() throws {
    try outProtocol.writeMessageBegin(name: "GetServiceId", type: .call, sequenceID: 0)
    let args = EOG_Service_GetServiceId_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_GetServiceId() throws -> ServiceId_s {
    try inProtocol.readResultMessageBegin() 
    let result = try EOG_Service_GetServiceId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let error = result.error {
      throw error
    }
    throw TApplicationError(error: .missingResult(methodName: "GetServiceId"))
  }

  public func GetServiceId() throws -> ServiceId_s {
    try send_GetServiceId()
    try outProtocol.transport.flush()
    return try recv_GetServiceId()
  }

  private func send_Heartbeat(serviceId: ServiceId_s) throws {
    try outProtocol.writeMessageBegin(name: "Heartbeat", type: .call, sequenceID: 0)
    let args = EOG_Service_Heartbeat_args(serviceId: serviceId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_Heartbeat() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try EOG_Service_Heartbeat_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let error = result.error {
      throw error
    }
  }

  public func Heartbeat(serviceId: ServiceId_s) throws {
    try send_Heartbeat(serviceId: serviceId)
    try outProtocol.transport.flush()
    try recv_Heartbeat()
  }

  private func send_ClientConnected(serviceId: ServiceId_s) throws {
    try outProtocol.writeMessageBegin(name: "ClientConnected", type: .call, sequenceID: 0)
    let args = EOG_Service_ClientConnected_args(serviceId: serviceId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_ClientConnected() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try EOG_Service_ClientConnected_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let error = result.error {
      throw error
    }
  }

  public func ClientConnected(serviceId: ServiceId_s) throws {
    try send_ClientConnected(serviceId: serviceId)
    try outProtocol.transport.flush()
    try recv_ClientConnected()
  }

  private func send_ClientAboutToDisconnect(serviceId: ServiceId_s) throws {
    try outProtocol.writeMessageBegin(name: "ClientAboutToDisconnect", type: .call, sequenceID: 0)
    let args = EOG_Service_ClientAboutToDisconnect_args(serviceId: serviceId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_ClientAboutToDisconnect() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try EOG_Service_ClientAboutToDisconnect_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let error = result.error {
      throw error
    }
  }

  public func ClientAboutToDisconnect(serviceId: ServiceId_s) throws {
    try send_ClientAboutToDisconnect(serviceId: serviceId)
    try outProtocol.transport.flush()
    try recv_ClientAboutToDisconnect()
  }

  private func send_ConfigurationChanged(configName: String, configuration: String) throws {
    try outProtocol.writeMessageBegin(name: "ConfigurationChanged", type: .call, sequenceID: 0)
    let args = EOG_Service_ConfigurationChanged_args(configName: configName, configuration: configuration)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_ConfigurationChanged() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try EOG_Service_ConfigurationChanged_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let error = result.error {
      throw error
    }
  }

  public func ConfigurationChanged(configName: String, configuration: String) throws {
    try send_ConfigurationChanged(configName: configName, configuration: configuration)
    try outProtocol.transport.flush()
    try recv_ConfigurationChanged()
  }

}

extension EOG_ServiceProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["GetServiceId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try EOG_Service_GetServiceId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = EOG_Service_GetServiceId_result()
      do {
        result.success = try handler.GetServiceId()
      }
      catch let error as EOG_Error { result.error = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "GetServiceId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["Heartbeat"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try EOG_Service_Heartbeat_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = EOG_Service_Heartbeat_result()
      do {
        try handler.Heartbeat(serviceId: args.serviceId)
      }
      catch let error as EOG_Error { result.error = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "Heartbeat", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["ClientConnected"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try EOG_Service_ClientConnected_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = EOG_Service_ClientConnected_result()
      do {
        try handler.ClientConnected(serviceId: args.serviceId)
      }
      catch let error as EOG_Error { result.error = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "ClientConnected", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["ClientAboutToDisconnect"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try EOG_Service_ClientAboutToDisconnect_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = EOG_Service_ClientAboutToDisconnect_result()
      do {
        try handler.ClientAboutToDisconnect(serviceId: args.serviceId)
      }
      catch let error as EOG_Error { result.error = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "ClientAboutToDisconnect", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["ConfigurationChanged"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try EOG_Service_ConfigurationChanged_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = EOG_Service_ConfigurationChanged_result()
      do {
        try handler.ConfigurationChanged(configName: args.configName, configuration: args.configuration)
      }
      catch let error as EOG_Error { result.error = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "ConfigurationChanged", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = EOG_ServiceProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

